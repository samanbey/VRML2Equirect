/* 
 * Copyright (C) 2016 Mátyás Gede <saman at map.elte.hu>
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package saman.globe;

import java.awt.Color;
import static java.awt.Cursor.getPredefinedCursor;
import java.awt.Dimension;
import java.awt.Graphics;
import java.awt.Point;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;
import java.awt.image.BufferedImage;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
import static java.lang.Math.*;
import java.util.ArrayList;
import java.util.List;
import java.util.Scanner;
import javax.imageio.ImageIO;
import javax.swing.JFileChooser;
import javax.swing.filechooser.FileFilter;
import saman.image.ImageViewer;

/**
 * Creates equirectangular globe map from VRML globe model
 * @author saman
 */
public class VRML2Equirect extends javax.swing.JFrame implements MouseListener {

    /**
     * Creates new form TransformGlobeFrame
     */
    public VRML2Equirect() {
        initComponents();
    }
    
   
    public void mousePressed(MouseEvent e) {}
    public void mouseReleased(MouseEvent e) {}
    public void mouseEntered(MouseEvent e) {}
    public void mouseExited(MouseEvent e) {}
    public void mouseClicked(MouseEvent e) {
        // mouse click listener
        // Aligns pole or prime meridian to the selected point
        Point p=latLonPreview.getImageCoord(e.getPoint());
        Dimension s=latLonPreview.getImageSize();
        double fi=90-(double)p.y*180/s.height;
        double la=(double)p.x*360/s.width-180;
        System.out.println(fi+"/"+la);
        if (settingPole) {
            latLonPreview.addMarker("NP", p);
            settingPole=false;
            latLonPreview.removeMouseListener(this);            
            setPoleButton.setEnabled(true);
            latLonPreview.setCursor(getPredefinedCursor(DEFAULT_CURSOR));
            // set metapole position
            // TODO: calculations when fi0/la0 is already set
            fi0=fi*rad;
            la0=la*rad;
            if (latLonPreview.showGrid) {
                latLonPreview.createGrid(fi0,la0,dlc);
            }
        }
        if (settingPM) {
            latLonPreview.addMarker("PM", p);
            settingPM=false;
            latLonPreview.removeMouseListener(this);            
            setPMButton.setEnabled(true);
            latLonPreview.setCursor(getPredefinedCursor(DEFAULT_CURSOR));
            // calculate dla
            // TODO: calculations when fi0/la0 is already set
            double fc=asin(sin(fi*rad)*sin(fi0)+cos(fi*rad)*cos(fi0)*cos(la*rad-la0));
            dlc=acos((sin(fi*rad)-sin(fi0)*sin(fc))/cos(fi0)/cos(fc))*(sin(la0-la*rad)>0?1:-1);
            if (latLonPreview.showGrid) {
                latLonPreview.createGrid(fi0,la0,dlc);
            }
        }
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jLabel1 = new javax.swing.JLabel();
        wrlfnTF = new javax.swing.JTextField();
        jButton1 = new javax.swing.JButton();
        jScrollPane1 = new javax.swing.JScrollPane();
        logBox = new javax.swing.JTextArea();
        transformButton = new javax.swing.JButton();
        setPoleButton = new javax.swing.JButton();
        setPMButton = new javax.swing.JButton();
        fullResCB = new javax.swing.JCheckBox();
        graticuleCB = new javax.swing.JCheckBox();
        latLonPreview = new saman.image.GeoViewer();

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);

        jLabel1.setText("3D model VRML flie:");

        jButton1.setText("Browse...");
        jButton1.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButton1ActionPerformed(evt);
            }
        });

        logBox.setColumns(20);
        logBox.setRows(5);
        logBox.setMaximumSize(new java.awt.Dimension(2147483647, 150));
        jScrollPane1.setViewportView(logBox);

        transformButton.setText("Transform!");
        transformButton.setEnabled(false);
        transformButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                transformButtonActionPerformed(evt);
            }
        });

        setPoleButton.setText("Set pole");
        setPoleButton.setEnabled(false);
        setPoleButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                setPoleButtonActionPerformed(evt);
            }
        });

        setPMButton.setEnabled(false);
        setPMButton.setLabel("Set PM");
        setPMButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                setPMButtonActionPerformed(evt);
            }
        });

        fullResCB.setText("Full resolution");

        graticuleCB.setLabel("Graticule");
        graticuleCB.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                graticuleCBActionPerformed(evt);
            }
        });

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(latLonPreview, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addGroup(layout.createSequentialGroup()
                        .addComponent(jLabel1)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(wrlfnTF, javax.swing.GroupLayout.DEFAULT_SIZE, 410, Short.MAX_VALUE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(jButton1))
                    .addComponent(jScrollPane1)
                    .addGroup(layout.createSequentialGroup()
                        .addComponent(transformButton)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(setPoleButton)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(setPMButton)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(fullResCB)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(graticuleCB)
                        .addGap(0, 0, Short.MAX_VALUE)))
                .addContainerGap())
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jLabel1)
                    .addComponent(wrlfnTF, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(jButton1))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(latLonPreview, javax.swing.GroupLayout.DEFAULT_SIZE, 280, Short.MAX_VALUE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(transformButton)
                    .addComponent(setPoleButton)
                    .addComponent(setPMButton)
                    .addComponent(fullResCB)
                    .addComponent(graticuleCB))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jScrollPane1, javax.swing.GroupLayout.PREFERRED_SIZE, 147, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addContainerGap())
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

    private void jButton1ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButton1ActionPerformed
        // Browse button pressed
        
        class WrlFilter extends FileFilter{
            public boolean accept(File f) {
                return f.isDirectory()||f.getName().toUpperCase().endsWith(".WRL");
            }
            public String getDescription() {
                return "VRML files";
            }
        }
        
        JFileChooser of = new JFileChooser();
        WrlFilter wf=new WrlFilter();
        of.addChoosableFileFilter(wf);
        of.setFileFilter(wf);
        if (of.showOpenDialog(null)==JFileChooser.APPROVE_OPTION) {
            File f=of.getSelectedFile();
            wrlfnTF.setText(f.getPath());
            if (readWrl(f))
                transformButton.setEnabled(true); 
        }
    }//GEN-LAST:event_jButton1ActionPerformed

    private void transformButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_transformButtonActionPerformed
        // Transform button pressed
        
        double ax=0,ay=0,az=0,minx=Double.POSITIVE_INFINITY,miny=minx,minz=minx,maxx=-minx,maxy=maxx,maxz=maxx;
        double r,r2;
        // find best fitting sphere
        //
        // find average coordinates and bounding box
        for (int i=0;i<pointsX.size();i++) {
            ax+=pointsX.get(i);
            ay+=pointsY.get(i);
            az+=pointsZ.get(i);
            if (minx>pointsX.get(i)) minx=pointsX.get(i);
            if (maxx<pointsX.get(i)) maxx=pointsX.get(i);
            if (miny>pointsY.get(i)) miny=pointsY.get(i);
            if (maxy<pointsY.get(i)) maxy=pointsY.get(i);
            if (minz>pointsZ.get(i)) minz=pointsZ.get(i);
            if (maxz<pointsZ.get(i)) maxz=pointsZ.get(i);
        }
        // ax,ay,az: average coords
        ax/=pointsX.size();ay/=pointsY.size();az/=pointsZ.size();
        // ax2,ay2,az2: centre of bounding box
        double ax2=(minx+maxx)/2;
        double ay2=(miny+maxy)/2;
        double az2=(minz+maxz)/2;
        r=(maxx-minx)/2;
        r2=(maxy-miny)/2;
        log(ax+" "+ay+" "+az+" - "+ax2+" "+ay2+" "+az2);
        // estimating best fitting sphere with Nelder-Mead method
        // initial simplex is generated from averaged point coordinates and bounding box
        double [] est=new double[6];
        double[][] pts={{ax,ay,az,r},{ax2,ay,az,r},{ax,ay2,az,r},{ax,ay,az2,r},{ax,ay,az,r2}};
        double eprev;
        est[4]=Double.POSITIVE_INFINITY;
        int cnt=0;        
        do {           
            eprev=est[4];
            for (int i=0;i<5;i++)
                est[i]=error(pointsX,pointsY,pointsZ,pts[i][0],pts[i][1],pts[i][2],pts[i][3]);
            for (int i=4;i>=0;i--) 
                for(int j=0;j<i;j++)
                    if (est[j]>est[j+1]) {
                        double x=est[j];est[j]=est[j+1];est[j+1]=x;
                        double[] xx=pts[j].clone();pts[j]=pts[j+1];pts[j+1]=xx;
                    }
           /* for(int i=0;i<5;i++)
                System.out.print(" e"+i+": "+e[i]);*/
            double[] p0=new double[4];
            for (int i=0;i<4;i++)
                p0[i]=(pts[0][i]+pts[1][i]+pts[2][i]+pts[3][i])/4;
            double e0=error(pointsX,pointsY,pointsZ,p0[0],p0[1],p0[2],p0[3]);
            double[] pr=new double[4];
            for (int i=0;i<4;i++)
                pr[i]=2*p0[i]-pts[4][i];
            double er=error(pointsX,pointsY,pointsZ,pr[0],pr[1],pr[2],pr[3]);
            if (er>=est[0]&&er<=est[1]) {
                pts[4]=pr;
                //System.out.println("pr");
            }
            else if (er<est[3]) {
                double[] pe=new double[4];
                for (int i=0;i<4;i++)
                    pe[i]=p0[i]-2*(p0[i]-pts[4][i]);
                double ee=error(pointsX,pointsY,pointsZ,pe[0],pe[1],pe[2],pe[3]);
                pts[4]=ee<er?pe:pr;
                //System.out.println(ee<er?"pe":"pr");
            }
            else {
                double[] pc=new double[4];
                for (int i=0;i<4;i++)
                    pc[i]=(p0[i]+pts[4][i])/2;
                double ec=error(pointsX,pointsY,pointsZ,pc[0],pc[1],pc[2],pc[3]);
                if (ec<est[4]) {
                    pts[4]=pc;
                    //System.out.println("pc");
                }    
                else {
                    for (int i=1;i<5;i++) 
                        for (int j=0;j<4;j++)
                            pts[i][j]=(pts[i][j]+pts[0][j])/2;
                    //System.out.println("shrink");
                }    
            }
            //System.out.println(ax+" "+ay+" "+az+" "+r+" e0="+e[0]+" e4="+e[4]);
        } while (++cnt<50&&eprev-est[4]>r/20);
        log("cnt: "+cnt);
        ax=pts[0][0];ay=pts[0][1];az=pts[0][2];
        log("center: "+ax+" "+ay+" "+az);

        double[] fi=new double[pointsX.size()]; // texture coords for lon/lat proj
        double[] la=new double[pointsX.size()];
        double[] Nx=new double[pointsX.size()]; // texture coords for azimuthal equidistant proj on the North Pole
        double[] Ny=new double[pointsX.size()];
        double[] Sx=new double[pointsX.size()]; // texture coords for azimuthal equidistant proj on the North Pole
        double[] Sy=new double[pointsX.size()];
        
        // load texture image
        BufferedImage inImg;
        try {
            inImg=ImageIO.read(new File(texPath+texFn));
        } catch (IOException e) {
            log("Image read error: ("+e.getMessage()+") in "+texPath+texFn);
            return;
        }
        int inW=inImg.getWidth();
        int inH=inImg.getHeight();

        int w=(fullResCB.isSelected())?((int)(inW*1.2)):3600; // output texture width;
        int h=w/2;
        int azw=w/4;
        
        double dx,dy,dz,minr=Double.POSITIVE_INFINITY,maxr=0;
        double f,l,fc,coslc,lc;
        for(int i=0;i<pointsX.size();i++) {
            dx=pointsX.get(i)-ax;
            dy=pointsY.get(i)-ay;
            dz=pointsZ.get(i)-az;
            r=sqrt(dx*dx+dy*dy+dz*dz);
            if (minr>r) minr=r;
            if (maxr<r) maxr=r;
            f=asin(dz/r);
            l=atan2(dy,dx);
            if (fi0==90*rad&&la0==0) {
                fc=f;lc=l; // first round - no rotation
            }
            else {
                fc=asin(sin(f)*sin(fi0)+cos(f)*cos(fi0)*cos(l-la0));
                coslc=(sin(f)-sin(fi0)*sin(fc))/cos(fi0)/cos(fc);
                if (coslc>1) coslc=1;
                if (coslc<-1) coslc=-1;
                lc=acos(coslc)*(sin(l-la0)>0?-1:1)-dlc;
                if (lc<-PI) lc+=2*PI;
                if (lc>PI) lc-=2*PI;                
            }
            // pixel coords for lon/lat
            fi[i]=(PI/2-fc)*h/PI;
            la[i]=(PI+lc)*w/2/PI;
            // pixel coords for north polar azimuthal
            Nx[i]=azw/2+(PI/2-fc)*sin(lc)*azw/PI*2;
            Ny[i]=azw/2+(PI/2-fc)*cos(lc)*azw/PI*2;
            //pixel coords for south polar azimuthal
            Sx[i]=azw/2+(PI/2+fc)*sin(lc)*azw/PI*2;
            Sy[i]=azw/2-(PI/2+fc)*cos(lc)*azw/PI*2;
            /*if (i%100==0)
                System.out.println(dx+","+dy+","+dz+" -> "+(90-fi[i]/h*180)+" "+(la[i]/w*360-180));*/
        }
        System.out.println("spherical coordinates calculated.");
        System.out.println(minr+" <= r <= "+maxr);

        String outTexFn=texPath+"latlon_"+texFn;
        
        try {
            BufferedImage outImg=new BufferedImage(w,h,BufferedImage.TYPE_INT_RGB);
            BufferedImage outNImg=new BufferedImage(azw,azw,BufferedImage.TYPE_INT_RGB);
            BufferedImage outSImg=new BufferedImage(azw,azw,BufferedImage.TYPE_INT_RGB);

            // texture transform
            double xi1,yi1,xi2,yi2,xi3,yi3;
            double xo1,yo1,xo2,yo2,xo3,yo3;
            double sw;
            int xi,yi;
            double[][] A=new double[3][3];
            double[] b=new double[3];
            double[] xa,ya; // transformation coefficients
            cnt=0;
            for(int i=0;i<texIndex.size();i+=4) { // 4 indexes for each triangle, the last one is -1
                // copy triangular area
                // calculate and apply transformation parameters for lon/lat
                xo1=la[coordIndex.get(i)];
                xo2=la[coordIndex.get(i+1)];
                xo3=la[coordIndex.get(i+2)];
                yo1=fi[coordIndex.get(i)];
                yo2=fi[coordIndex.get(i+1)];
                yo3=fi[coordIndex.get(i+2)];
                xi1=texPointsX.get(texIndex.get(i));
                xi2=texPointsX.get(texIndex.get(i+1));
                xi3=texPointsX.get(texIndex.get(i+2));
                yi1=texPointsY.get(texIndex.get(i));
                yi2=texPointsY.get(texIndex.get(i+1));
                yi3=texPointsY.get(texIndex.get(i+2));
                copyTriangle(xo1,yo1,xo2,yo2,xo3,yo3,xi1,yi1,xi2,yi2,xi3,yi3,outImg,inImg,true);
                // calculate and apply northern azimuthal proj parameters for the upper quarter
                if(yo1<=h/4||yo2<=h/4||yo3<=h/4) {
                    xo1=Nx[coordIndex.get(i)];
                    xo2=Nx[coordIndex.get(i+1)];
                    xo3=Nx[coordIndex.get(i+2)];
                    yo1=Ny[coordIndex.get(i)];
                    yo2=Ny[coordIndex.get(i+1)];
                    yo3=Ny[coordIndex.get(i+2)];
                    copyTriangle(xo1,yo1,xo2,yo2,xo3,yo3,xi1,yi1,xi2,yi2,xi3,yi3,outNImg,inImg,false);
                }
                // calculate and apply southern azimuthal proj parameters for the upper quarter
                if(yo1>=3*h/4||yo2>=3*h/4||yo3>=3*h/4) {
                    xo1=Sx[coordIndex.get(i)];
                    xo2=Sx[coordIndex.get(i+1)];
                    xo3=Sx[coordIndex.get(i+2)];
                    yo1=Sy[coordIndex.get(i)];
                    yo2=Sy[coordIndex.get(i+1)];
                    yo3=Sy[coordIndex.get(i+2)];
                    copyTriangle(xo1,yo1,xo2,yo2,xo3,yo3,xi1,yi1,xi2,yi2,xi3,yi3,outSImg,inImg,false);
                }
            }
            // transform and merge northern azimuthal image to lon-lat
            for(int x=0;x<w;x++)
                for(int y=0;y<h/4;y++) {
                    double gamma=x*2*PI/w-PI;
                    int nx=azw/2+(int)round(y*sin(gamma));
                    int ny=azw/2+(int)round(y*cos(gamma));
                    if (nx>=azw) nx=azw-1;
                    if (ny>=azw) ny=azw-1;
                    outImg.setRGB(x,y,outNImg.getRGB(nx,ny));
                }
            // transform and merge southern azimuthal image to lon-lat
            for(int x=0;x<w;x++)
                for(int y=3*h/4;y<h;y++) {
                    double gamma=x*2*PI/w-PI;
                    int nx=azw/2+(int)round((h-1-y)*sin(gamma));
                    int ny=azw/2-(int)round((h-1-y)*cos(gamma));
                    if (nx>=azw) nx=azw-1;
                    if (ny>=azw) ny=azw-1;
                    outImg.setRGB(x,y,outSImg.getRGB(nx,ny));
                }
            try {
                ImageIO.write(outImg,"jpg",new File(outTexFn));
            } catch (IOException e) {
                log("Error writing image file.");
                return;
            }
            log(cnt+" triangle(s) with wrong coordinates.");
            log("lat/lon texture created in file "+outTexFn);        
            latLonPreview.setImage(outImg);
        } catch (Exception e) {
            log("An error occured: "+e);
        }
        setPoleButton.setEnabled(true);
        setPMButton.setEnabled(true);
    }//GEN-LAST:event_transformButtonActionPerformed

    private void setPoleButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_setPoleButtonActionPerformed
        // activating mouse event handler to set the position of the North Pole
        latLonPreview.setCursor(getPredefinedCursor(CROSSHAIR_CURSOR));
        latLonPreview.removeMouseListener(this);
        latLonPreview.addMouseListener(this);
        settingPole=true;
        setPoleButton.setEnabled(false);
    }//GEN-LAST:event_setPoleButtonActionPerformed

    private void setPMButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_setPMButtonActionPerformed
        // activating mouse event handler to set the position of the North Pole
        latLonPreview.setCursor(getPredefinedCursor(CROSSHAIR_CURSOR));
        latLonPreview.removeMouseListener(this);
        latLonPreview.addMouseListener(this);
        settingPM=true;
        setPMButton.setEnabled(false);
    }//GEN-LAST:event_setPMButtonActionPerformed

    private void graticuleCBActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_graticuleCBActionPerformed
        latLonPreview.showGrid=graticuleCB.isSelected();
        if (latLonPreview.showGrid) {
            latLonPreview.createGrid(fi0,la0,dlc);
        }
        else
            latLonPreview.repaint();
    }//GEN-LAST:event_graticuleCBActionPerformed

    // solving the Ax=B linear equation system
    private double[] solve(double[][] Abe, double[] bbe) {
        int n=Abe.length;
        double[][] A=new double[n][n];
        double[] b=new double[n];        
        int i,j,k;
        // copy to local array
        for(i=0;i<n;i++) {
            b[i]=bbe[i];
            for(j=0;j<n;j++)
                A[i][j]=Abe[i][j];
        }
        // Gaussian elimination
        for(i=0;i<n-1;i++) {
            // if A[i][i]==0, find row j where A[j][i]!=0
            for(j=i;j<n&&A[j][i]==0;j++);
            // if exists, swap rows
            if (j>i) { // A[i][i]==0, so we have to swap
                if (j>=n) { // j is over n, so all coefficients are 0
                    System.err.println("Houston, we have problem!");
                    return null;
                }
                else {// A[j][i]!=0, so let's swap
                    for(k=i;k<n;k++) {
                        double cs=A[i][k];A[i][k]=A[j][k];A[j][k]=cs;
                    }
                    double cs=b[i];b[i]=b[j];b[j]=cs;
                }
            }
            for(j=i+1;j<n;j++) {
                double h=A[j][i]/A[i][i];
                A[j][i]=0; // really A[j][i]-=A[i][i]*h, but it means 0.
                for(k=i+1;k<n;k++)
                    A[j][k]-=A[i][k]*h;
                b[j]-=b[i]*h;
            }
        }
        // substituting back
        for(i=n-1;i>=0;i--) {
            b[i]/=A[i][i];
            A[i][i]=1;
            for(j=i-1;j>=0;j--) {
                b[j]-=A[j][i]*b[i];
                A[j][i]=0;
            }
        }
        // solution is in vector b
        return b;
    }
    
    // error function for finding best fit sphere
    private double error(List<Double> px,List<Double> py,List<Double> pz, double x0, double y0, double z0, double r) {
        double s=0;
        for(int i=0;i<px.size();i++) {
            double d=(px.get(i)-x0)*(px.get(i)-x0)+(py.get(i)-y0)*(py.get(i)-y0)+(pz.get(i)-z0)*(pz.get(i)-z0)-r*r;
            s+=d*d;
        }
        return s;
    }
    
    // adding text to the log box
    private void log(String s) {
        logBox.append(s+"\n");
    }
    
    // read and parse wrl file
    private boolean readWrl(File f) {

        String agiWrlFn=f.getPath();
        String fn=f.getName();
        log("Opening "+agiWrlFn+"...");

        Scanner inFile;
        try {
            inFile=new Scanner(new FileInputStream(agiWrlFn));
        }
        catch (FileNotFoundException e) {
            log("File not found error!");
            return false;
        }
        String s="";
        String[] p,p2;
        int cnt=0;
        // find "Coordinate"
        while(inFile.hasNext()&&!inFile.next().equals("Coordinate"));
        while(inFile.hasNext()&&!inFile.next().equals("["));
        while(inFile.hasNext()&&!s.equals("]")) {
            s=inFile.nextLine().trim();
            cnt++;
            p=s.split(",");
            for (String p1 : p) {
                p2=p1.trim().split(" ");
                if (p2.length==3) {
                    pointsX.add(Double.parseDouble(p2[0]));
                    pointsY.add(Double.parseDouble(p2[1]));
                    pointsZ.add(Double.parseDouble(p2[2]));
                }
            }
        }
        // find "TextureCoordinate"
        while(inFile.hasNext()&&!inFile.next().equals("TextureCoordinate")) cnt++;
        while(inFile.hasNext()&&!inFile.next().equals("[")) cnt++;
        s="";
        while(inFile.hasNext()&&!s.equals("]")) {
            s=inFile.nextLine().trim();
            cnt++;
            p=s.split(",");
            for (String p1 : p) {
                p2=p1.trim().split(" ");
                if (p2.length==2) {
                    texPointsX.add(Double.parseDouble(p2[0]));
                    texPointsY.add(1-Double.parseDouble(p2[1]));
                }
            }
        }
        // find "texCoordIndex"
        while(inFile.hasNext()&&!inFile.next().equals("texCoordIndex")) cnt++;
        while(inFile.hasNext()&&!inFile.next().equals("[")) cnt++;
        s="";
        while(inFile.hasNext()&&!s.equals("]")) {
            s=inFile.nextLine().trim();
            p=s.split(",");
            if (p.length>1)
                for (String p1 : p) {
                    texIndex.add(Integer.parseInt(p1.trim()));
                }
        }
        // find "coordIndex"
        while(inFile.hasNext()&&!inFile.next().equals("coordIndex")) cnt++;
        while(inFile.hasNext()&&!inFile.next().equals("[")) cnt++;
        s="";
        while(inFile.hasNext()&&!s.equals("]")) {
            s=inFile.nextLine().trim();
            p=s.split(",");
            if (p.length>1)
                for (String p1 : p) {
                    coordIndex.add(Integer.parseInt(p1.trim()));
                }
        }
        log("Mesh points: "+pointsX.size()+", texture points: "+texPointsX.size());
        log("Texture indexes: "+texIndex.size()+", coord indexes: "+coordIndex.size());

        // find texture file name
        while(inFile.hasNext()&&!inFile.next().equals("url"));
        texFn=inFile.next();
        texPath=f.getParent()+File.separator;
        if (texFn.charAt(0)=='\"'&&texFn.charAt(texFn.length()-1)=='\"')
            texFn=texFn.substring(1,texFn.length()-1); // remove quotmarks if neccessary
        log("Texture file name: "+texPath+texFn);
        
        log("File read successfully.");
        return true;
    }

    
    /**
     * function to copy triangular area with transformation
     * @param lonlat true if the output is equirectangular so we have to take care of the antimeridian
     */
    private void copyTriangle(double xo1, double yo1, double xo2, double yo2, double xo3, double yo3,
                             double xi1, double yi1, double xi2, double yi2, double xi3, double yi3,
                             BufferedImage outImg, BufferedImage inImg, boolean lonLat) {
        double[][] A=new double[3][3];
        double[] b=new double[3];
        double[] xa,ya;
        double sw;
        int xi,yi;
        int w=outImg.getWidth();
        int h=outImg.getHeight();
        int inW=inImg.getWidth();
        int inH=inImg.getHeight();
        
        // handling triangles crossing the antimeridian if lonLat
        if (lonLat&&
                (abs(xo2-xo1)>w*.5||abs(xo3-xo1)>w*.5||abs(xo3-xo1)>w*.5)) {
            if (xo1<w/2) xo1+=w;
            if (xo2<w/2) xo2+=w;
            if (xo3<w/2) xo3+=w;
        }
        A[0][0]=xo1;
        A[1][0]=xo2;
        A[2][0]=xo3;
        A[0][1]=yo1;
        A[1][1]=yo2;
        A[2][1]=yo3;
        A[0][2]=A[1][2]=A[2][2]=1;
        b[0]=xi1;
        b[1]=xi2;
        b[2]=xi3;
        xa=solve(A,b);
        b[0]=yi1;
        b[1]=yi2;
        b[2]=yi3;
        ya=solve(A,b);
        //System.out.println(xi1+","+yi1+" "+xi2+","+yi2+" "+xi3+","+yi3+" -> "+xo1+","+yo1+" "+xo2+","+yo2+" "+xo3+","+yo3);
        // select lowest cp
        if (yo2<yo1) {
            sw=yo2;yo2=yo1;yo1=sw;
            sw=xo2;xo2=xo1;xo1=sw;
            sw=yi2;yi2=yi1;yi1=sw;
            sw=xi2;xi2=xi1;xi1=sw;
        }
        if (yo3<yo1) {
            sw=yo3;yo3=yo1;yo1=sw;
            sw=xo3;xo3=xo1;xo1=sw;
            sw=yi3;yi3=yi1;yi1=sw;
            sw=xi3;xi3=xi1;xi1=sw;
        }
        // select highest cp
        if (yo2>yo3) {
            sw=yo3;yo3=yo2;yo2=sw;
            sw=xo3;xo3=xo2;xo2=sw;
            sw=yi3;yi3=yi2;yi2=sw;
            sw=xi3;xi3=xi2;xi2=sw;
        }
        for (int y=(int)round(yo1);y<=yo3;y++) {
            int x1,x2,xsw;
            if (y<yo2)
                x1=(int)round(xo1+(y-yo1)*(xo2-xo1)/(yo2-yo1));
            else
                x1=(int)round(xo2+(y-yo2)*(xo3-xo2)/(yo3-yo2));
            x2=(int)round(xo1+(y-yo1)*(xo3-xo1)/(yo3-yo1));
            if (x2<x1) {
                xsw=x1;x1=x2;x2=xsw;
            }
            for (int x=x1;x<=x2;x++) {
                xi=(int)round((xa[0]*x+xa[1]*y+xa[2])*inW);
                yi=(int)round((ya[0]*x+ya[1]*y+ya[2])*inH);
                if (xi<0) xi=0;
                if (yi<0) yi=0;
                if (xi>inW-1) xi=inW-1;
                if (yi>inH-1) yi=inH-1;
                if(x>=0&&y>=0&&y<h) {
                    if (x<w)
                        outImg.setRGB(x,y,inImg.getRGB(xi,yi));
                    else // triangles on antimeridian and lonLat
                        if (lonLat&&x<2*w) 
                            outImg.setRGB(x-w,y,inImg.getRGB(xi,yi));
                        else System.out.println("x="+x+" y="+y);
                } 
            }
        }
        
    }
    
    /**
     * @param args the command line arguments
     */
    public static void main(String args[]) {
        /* Set the Nimbus look and feel */
        //<editor-fold defaultstate="collapsed" desc=" Look and feel setting code (optional) ">
        /* If Nimbus (introduced in Java SE 6) is not available, stay with the default look and feel.
         * For details see http://download.oracle.com/javase/tutorial/uiswing/lookandfeel/plaf.html 
         */
        try {
            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
                if ("Nimbus".equals(info.getName())) {
                    javax.swing.UIManager.setLookAndFeel(info.getClassName());
                    break;
                }
            }
        } catch (ClassNotFoundException ex) {
            java.util.logging.Logger.getLogger(VRML2Equirect.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (InstantiationException ex) {
            java.util.logging.Logger.getLogger(VRML2Equirect.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (IllegalAccessException ex) {
            java.util.logging.Logger.getLogger(VRML2Equirect.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (javax.swing.UnsupportedLookAndFeelException ex) {
            java.util.logging.Logger.getLogger(VRML2Equirect.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        }
        //</editor-fold>
        //</editor-fold>

        /* Create and display the form */
        java.awt.EventQueue.invokeLater(new Runnable() {
            public void run() {
                new VRML2Equirect().setVisible(true);
            }
        });
    }

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JCheckBox fullResCB;
    private javax.swing.JCheckBox graticuleCB;
    private javax.swing.JButton jButton1;
    private javax.swing.JLabel jLabel1;
    private javax.swing.JScrollPane jScrollPane1;
    private saman.image.GeoViewer latLonPreview;
    private javax.swing.JTextArea logBox;
    private javax.swing.JButton setPMButton;
    private javax.swing.JButton setPoleButton;
    private javax.swing.JButton transformButton;
    private javax.swing.JTextField wrlfnTF;
    // End of variables declaration//GEN-END:variables

    final static double rad=PI/180;
    double fi0=90*rad; // pole position
    double la0=0; 
    double dlc=0; // rotation
    boolean settingPole=false, settingPM=false;
    List<Double> pointsX=new ArrayList<>();
    List<Double> pointsY=new ArrayList<>();
    List<Double> pointsZ=new ArrayList<>();
    List<Double> texPointsX=new ArrayList<>();
    List<Double> texPointsY=new ArrayList<>();
    List<Integer> texIndex=new ArrayList<>();
    List<Integer> coordIndex=new ArrayList<>();
    
    String texFn, texPath; // texture file name and its path

}
